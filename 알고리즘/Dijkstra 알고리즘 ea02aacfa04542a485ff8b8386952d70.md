# Dijkstra 알고리즘

# 최단경로

- 정점 u와 정점v를 연결하는 경로 중 간선들의 가중치 합이 최소가 되는 경로를 찾기
- 즉, 간선의 가중치( 비용, 거리, 시간 등 )에 따라서 결정되는 것
    - 최단경로 : (0,4,1,2,3)    /    비용 : 3+2+4+2 = 11
    - 0 → 4 → 1 → 2 → 3
- 그림상으로 봤을 때 가장 짧은 거리에 따라 결정되는 것이 아님
    - 0 → 1 → 3

![Dijkstra%20%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%80%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B3%E1%86%B7%20ea02aacfa04542a485ff8b8386952d70/_2021-05-11__7.26.17.png](Dijkstra%20%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%80%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B3%E1%86%B7%20ea02aacfa04542a485ff8b8386952d70/_2021-05-11__7.26.17.png)

# 가중치 인접행렬

- 가중치는 가중치 인접행렬인 2차원 배열에 저장
- 간선이 없는 구간은 ∞
- 간선의 가중치는 0 ~ 양의 정수

![Dijkstra%20%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%80%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B3%E1%86%B7%20ea02aacfa04542a485ff8b8386952d70/_2021-05-12__1.21.40.png](Dijkstra%20%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%80%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B3%E1%86%B7%20ea02aacfa04542a485ff8b8386952d70/_2021-05-12__1.21.40.png)

# Dijkstra 최단 경로 알고리즘

## 1) 구현 과정

: 네트워크에서 하나의 시작 정점으로부터 모든 다른 정점까지의 최단 경로를 찾는 알고리즘

- 시작 정점에서 집합 S에 있는 정점만을 거쳐서 다른 정점으로 가는 최단거리를 기록하는 배열이 반드시 필요
- 집합 S에는 최단 거리에 해당하는 정점이 하나씩 추가될 예정

---

1. 최단 거리 기록하는 1차원 배열 distance 생성후 값 지정
    1. 시작정점 v, 다른 정점 w
        - distance[v] = 0
    2. distance 값은 두 정점간의 가중치
        - 가중치 인접행렬 weight로 설정
        - distance[w] = weight[v][w]
    3. 만약 정점 v,w 사이의 간선이 없을 경우 무한대 값
        - distance[w] = ∞
2. 집합 S 진행 과정
    1. 시작 단계 : S = {v}
    2. 최단 거리가 발견되는 새로운 정점 u를 S에 추가
        - 집합 S에 있지 않는 정점
        - 가장 distance 값이 작은 정점
    3. S에 있지 않은 다른 정점들의 distance값 수정 
        - 시작 기준점 u
        - distance[w] = min(distance[w], distance[u] + weight[u][w])

---

## 2) 그림으로 설명

1. 첫번재 과정
    - 그림

        ![Dijkstra%20%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%80%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B3%E1%86%B7%20ea02aacfa04542a485ff8b8386952d70/_2021-05-12__6.59.36.png](Dijkstra%20%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%80%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B3%E1%86%B7%20ea02aacfa04542a485ff8b8386952d70/_2021-05-12__6.59.36.png)

    - 설명
        1. 시작 정점 0 
        2. 시작 정점에 대한 각 지점들의 거리 표시
        3. 정점 4이 가장 짧은거리인 3
        4. 집합S에 정점 4 추가

2. 두번째 과정
    - 그림

        ![Dijkstra%20%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%80%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B3%E1%86%B7%20ea02aacfa04542a485ff8b8386952d70/_2021-05-12__7.01.48.png](Dijkstra%20%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%80%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B3%E1%86%B7%20ea02aacfa04542a485ff8b8386952d70/_2021-05-12__7.01.48.png)

    - 설명
        1. 시작 기준점 4
        2. 시작 기준점을 기준으로 distance 값 변경 ( 4의 기본옵션값 3 )
            1. 이전 정점에서 직접적으로 갈 수 없던 정점을 새로운 시작 기준점을 통해 갈 수 있기 때문에 ∞ 에서 구체적 정수거리로 정보 갱신

                (이때, 시작 기준점까지의 거리는 기본 옵션으로 더해줌)

                예시 ) 시작 기준점 4의 거리는 3이므로 4와 인접정점들의 가중치에 3을 더함

                - 정점 3 : ∞ → 14 (3+11)
                - 정점 6 : ∞ → 8 (3+5)
            2. 새로운 시작 기준점을 통해 갈 때 더 짧은 경로가 발견되면 정보 갱신

                예시) 0번 점정만을 선택할 경우 1번 정점까지 7이였는데 4번 정점을 택함으로써 거리가 5로 줄어듬

                - 정점 1 : 7 → 5 (3+2)
        3. 최종으로 남은 정점 중 가중치가 가장 작은 건 정점 1
        4. 집합 S에 1을 추가하고 위와 같이 반복적으로 수행

3. 세번째 과정
    - 그림

        ![Dijkstra%20%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%80%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B3%E1%86%B7%20ea02aacfa04542a485ff8b8386952d70/_2021-05-12__7.25.59.png](Dijkstra%20%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%80%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B3%E1%86%B7%20ea02aacfa04542a485ff8b8386952d70/_2021-05-12__7.25.59.png)

    - 설명
        1. 시작 기준점 1
        2. 시작 기준점을 기준으로 distance 값 변경 ( 1의 기본옵션값 5 )
            1. 이전 정점에서 직접적으로 갈 수 없던 정점을 새로운 시작 기준점을 통해 갈 수 있기 때문에 ∞ 에서 구체적 정수거리로 정보 갱신
                - 정점 2 :  ∞ → 2 (5+4)
            2. 새로운 시작 기준점을 통해 갈 때 더 짧은 경로가 발견되면 정보 갱신
            3. 갱신 안된 이유
                - 정점 0,4 : 이미 다녀간 집합 S에 있기 때문에 패스
                - 정점 3 : 14 → 15 ( 값이 더 커짐 )
                - 정점 5 : 10 → 11 ( 값이 더 커짐 )
        3. 최종으로 남은 정점 중 가중치가 가장 작은 건 정점 6
        4. 집합 S에 6을 추가하고 위와 같이 반복적으로 수행
4. 네번째 과정
    - 그림

        ![Dijkstra%20%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%80%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B3%E1%86%B7%20ea02aacfa04542a485ff8b8386952d70/_2021-05-12__7.35.39.png](Dijkstra%20%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%80%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B3%E1%86%B7%20ea02aacfa04542a485ff8b8386952d70/_2021-05-12__7.35.39.png)

    - 설명
        1. 시작 기준점 6
        2. 시작 기준점을 기준으로 distance 값 변경 ( 6의 기본옵션값 8 )
            1. 이전 정점에서 직접적으로 갈 수 없던 정점을 새로운 시작 기준점을 통해 갈 수 있기 때문에 ∞ 에서 구체적 정수거리로 정보 갱신
            2. 새로운 시작 기준점을 통해 갈 때 더 짧은 경로가 발견되면 정보 갱신
                - 정점 3 :  14 → 12 (8+4)
            3. 갱신 안된 이유
                - 정점 4 : 이미 다녀간 집합 S에 있기 때문에 패스
        3. 최종으로 남은 정점 중 가중치가 가장 작은 건 정점 2
        4. 집합 S에 2을 추가하고 위와 같이 반복적으로 수행

5. 다섯번째 과정
    - 그림

    ![Dijkstra%20%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%80%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B3%E1%86%B7%20ea02aacfa04542a485ff8b8386952d70/_2021-05-12__7.40.11.png](Dijkstra%20%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%80%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B3%E1%86%B7%20ea02aacfa04542a485ff8b8386952d70/_2021-05-12__7.40.11.png)

    - 설명
        1. 시작 기준점 2
        2. 시작 기준점을 기준으로 distance 값 변경 ( 2의 기본옵션값 9 )
            1. 이전 정점에서 직접적으로 갈 수 없던 정점을 새로운 시작 기준점을 통해 갈 수 있기 때문에 ∞ 에서 구체적 정수거리로 정보 갱신
            2. 새로운 시작 기준점을 통해 갈 때 더 짧은 경로가 발견되면 정보 갱신
                - 정점 3 :  12 → 11 (9+2)
            3. 갱신 안된 이유
                - 정점 1 : 이미 다녀간 집합 S에 있기 때문에 패스
        3. 최종으로 남은 정점 중 가중치가 가장 작은 건 정점 2
        4. 집합 S에 5을 추가하고 위와 같이 반복적으로 수행

6. 여섯번째 과정
    - 그림

        생략

    - 설명
        1. 시작 기준점 5
        2. 시작 기준점을 기준으로 distance 값 변경 ( 5의 기본옵션값 10 )
            1. 갱신 안된 이유
                - 정점 0,1 : 이미 다녀간 집합 S에 있기 때문에 패스
                - 정점 3 : 11 → 19(10+9) 값이 더 커짐
        3. 최종으로 남은 정점 중 가중치가 가장 작은 건 정점 3
        4. 집합 S에 3을 추가

7. 마지막 과정
    - 마지막 정점인 3번 선택하고 끝낸다.

# 파이썬을 이용하여 다익스트라 구현하기

## 코드 1

```python
import heapq
import sys
input = sys.stdin.readline()
INF = int(1e9)  #무한을 의미하는 값으로 10억을 설정.

#노드의 개수, 간선의 개수를 입력받기
n, m = map(int, input().split())
#시작 노드 번호를 입력받기
start = int(input())
#각 노드에 연결되어 있는 노드에 대한 정보를 담는 리스트를 만들기
graph = [[] for i in range(n + 1)]
#최단 거리 테이블을 모두 무한으로 초기화
distance = [INF] * (n + 1)

#모든 간선 정보를 입력받기
for _ in range(m):
    a, b, c = map(int, input().split())
    #a번 노드에서 b번 노드로 가는 비용이 c라는 의미
    graph[a].append((b, c))

def dijkstra(start):
    q = []
    #시작 노드로 가기 위한 최단 경로는 0으로 설정하여, 큐에 삽입
    heapq.heappush(q, (0, start))
    distance[start] = 0
    while q:    #큐가 비어있지 않다면
        #가장 최단 거리가 짧은 노드에 대한 정보 꺼내기
        dist, now = heapq.heappop(q)
        # 현재 노드가 이미 처리된 적이 있는 노드라면 무시
        if distance[now] < dist:
            continue
        # 현재 노드와 연결된 다른 인접한 노드들을 확인
        for i in graph[now]:
            cost = dist + i[1]
            #현재 노드를 거쳐서, 다른 노드로 이동하는 거리가 더 짧은 경우
            if cost < distance[i[0]]:
                distance[i[0]] = cost
                heapq.heappush(q, (cost, i[0]))

dijkstra(start)

#모든 노드로 가기 위한 최단 거리를 출력
for i in range(1, n + 1):
    #도달할 수 없는 경우, 무한이라고 출력
    if distance[i] == INF:
        print("INFINITY")
    #도달할 수 있는 경우 거리를 출력
    else:
        print(distance[i])
```

## 코드 2

```python
import heapq
import sys

#입력
V, E = map(int, input().split())
K = int(input())
INF = 10 * V + 1 #최댓값 설정
distance = [[] for _ in range(V+1)] # V*V배열로 만들면 메모리가 초과된다

for _ in range(E):
    start, end, dist = map(int, sys.stdin.readline().split())
    distance[start].append([end, dist]) #시작 리스트에 도착지와 거리를 입력
    
    
#다익스트라 알고리즘
queue = [] #우선순위 큐 -> 힙으로 구현해줌
K_distance = [INF for _ in range(V+1)] #답이 될 K로부터의 거리
K_distance[K] = 0 #자기 자신은 0
heapq.heappush(queue, [0, K]) #자기 자신으로부터 우선순위 큐를 시작한다

while queue:
    mid = heapq.heappop(queue) #현재 가장 가까운 거리의 노드를 pop [거리, 노드 위치]
    for end in distance[mid[1]]: #가장 가까운 노드에 연결된 모든 노드들 end에 대하여
        if K_distance[end[0]] > mid[0] + end[1]: #mid노드를 거치는 게 end로 바로 가는 것보다 효율적이라면
            K_distance[end[0]] = mid[0] + end[1] #해당 거리를 저장
            heapq.heappush(queue, [K_distance[end[0]], end[0]]) #큐에 [갱신된 거리, 노드 위치] 삽입

#출력
for i in range(1, V+1):
    if K_distance[i] == INF:
        print("INF")
    else:
        print(K_distance[i])
```

- 해당 알고리즘 하나 문제 풀기

       : 289 백준 파이썬 [1766] 최단경로 - 다익스트라

[https://www.notion.so/Dijkstra-94d2e37919da40a9821f358c03f29598#03feaf6907234871beb666a87b62bfd0](https://www.notion.so/Dijkstra-94d2e37919da40a9821f358c03f29598#03feaf6907234871beb666a87b62bfd0)