# 플로이드와샬

- 모든 정점에서 모든 정점으로의 최단 경로를 구하고 싶을 때 (모든 정점들간의 최단 경로)
- 다익스트라는 가장 적은 비용을 하나씩 선택해야 했다면 플로이드와샬은 기본적으로 '거쳐가는 정점'을 기준으로 알고리즘을 수행한다는 점이 다르다
- 출발점이 정해져 있지 않은 경우
- 기본적으로 DP기술에 의거한다.

# 알고리즘 구현

플로이드-워셜 알고리즘은 경유하는 정점에 초점을 두고, 그 정점을 거쳐가는 경로가 기존 경로보다 더 효율적인지를 판단한다. 즉, 경유하는 정점의 입장에서 어떤 정점 u가 다른 정점 v로 갈 때 자신을 거쳐서 가는 것이 기존의 경로보다 더 효율적이라면 기존의 경로를 갱신해주는 작업을 반복하는 것이다.

플로이드 와샬의 기본 개념은 i에서 출발해 j로 가는 경로의 가중치를 저장하는 2차원 배열을 채우는데, i를 출발해 j로 바로 가는 것보다 k를 거쳐 j로 가는 게 효율적일 경우(저렴할 경우) 해당 값을 갱신해준다. k의 값을 가장 바깥 for문에서 반복해주므로 하나의 경유지 k만 거치는 것뿐만 아니라 여러 경유지를 거치는 경로또한 포함한다.

```python
# k : 경유지
for k in range(1, v+1):
    # i : 출발지    
    for i in range(1, v+1):
        # j : 목적지
        for j in range(1, v+1):
            dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j])
```

# 동작 과정

1. 간선들의 정보(정점, 간선의 길이)를 저장할 인접행렬을 만들고, 거리 값은 무한대로 초기화한다.
2. 인접행렬에 간선들의 정보를 저장한다. 이 때 두 정점 사이의 간선이 여러 개라면 더 짧은 간선을 저장한다.
3. 경유지를 기준으로, 어떤 두 정점이 해당 경유지를 거처갈 경우에 기존의 거리보다 더 짧다면 기존의 거리 값을 갱신한다.
4. 모든 정점을 경유지로 설정해 3번 과정을 반복한다.

# 시간, 공간 복잡도

- 정점의 개수 *V*만큼 반복분이 3중으로 수행되고 있기 때문에 *O*(*V***3)의 시간 복잡도
- 간선들의 정보를 *V*∗*V* 크기의 인접행렬에 담았기 때문에 *O*(*V***2)의 공간 복잡도

# 그림으로 설명

1. 초기상태 : 그래프를 준비하고 최단 거리 테이블을 초기화한다.

    ![%E1%84%91%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A9%E1%84%8B%E1%85%B5%E1%84%83%E1%85%B3%E1%84%8B%E1%85%AA%E1%84%89%E1%85%A3%E1%86%AF%203b5d2d5fd7624af4a045a0b69189c479/_2021-05-20__5.27.25.png](%E1%84%91%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A9%E1%84%8B%E1%85%B5%E1%84%83%E1%85%B3%E1%84%8B%E1%85%AA%E1%84%89%E1%85%A3%E1%86%AF%203b5d2d5fd7624af4a045a0b69189c479/_2021-05-20__5.27.25.png)

2. 1번노드를 거쳐가는 경우를 고려하여 테이블을 갱신한다.

    ![%E1%84%91%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A9%E1%84%8B%E1%85%B5%E1%84%83%E1%85%B3%E1%84%8B%E1%85%AA%E1%84%89%E1%85%A3%E1%86%AF%203b5d2d5fd7624af4a045a0b69189c479/_2021-05-20__5.27.58.png](%E1%84%91%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A9%E1%84%8B%E1%85%B5%E1%84%83%E1%85%B3%E1%84%8B%E1%85%AA%E1%84%89%E1%85%A3%E1%86%AF%203b5d2d5fd7624af4a045a0b69189c479/_2021-05-20__5.27.58.png)

3. 2번노드를 거쳐가는 경우를 고려하여 테이블을 갱신한다.

    ![%E1%84%91%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A9%E1%84%8B%E1%85%B5%E1%84%83%E1%85%B3%E1%84%8B%E1%85%AA%E1%84%89%E1%85%A3%E1%86%AF%203b5d2d5fd7624af4a045a0b69189c479/_2021-05-20__5.28.08.png](%E1%84%91%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A9%E1%84%8B%E1%85%B5%E1%84%83%E1%85%B3%E1%84%8B%E1%85%AA%E1%84%89%E1%85%A3%E1%86%AF%203b5d2d5fd7624af4a045a0b69189c479/_2021-05-20__5.28.08.png)

4. 3번노드를 거쳐가는 경우를 고려하여 테이블을 갱신한다.

    ![%E1%84%91%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A9%E1%84%8B%E1%85%B5%E1%84%83%E1%85%B3%E1%84%8B%E1%85%AA%E1%84%89%E1%85%A3%E1%86%AF%203b5d2d5fd7624af4a045a0b69189c479/_2021-05-20__5.28.16.png](%E1%84%91%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A9%E1%84%8B%E1%85%B5%E1%84%83%E1%85%B3%E1%84%8B%E1%85%AA%E1%84%89%E1%85%A3%E1%86%AF%203b5d2d5fd7624af4a045a0b69189c479/_2021-05-20__5.28.16.png)

5. 4번노드를 거쳐가는 경우를 고려하여 테이블을 갱신한다.

    ![%E1%84%91%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A9%E1%84%8B%E1%85%B5%E1%84%83%E1%85%B3%E1%84%8B%E1%85%AA%E1%84%89%E1%85%A3%E1%86%AF%203b5d2d5fd7624af4a045a0b69189c479/_2021-05-20__5.28.24.png](%E1%84%91%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A9%E1%84%8B%E1%85%B5%E1%84%83%E1%85%B3%E1%84%8B%E1%85%AA%E1%84%89%E1%85%A3%E1%86%AF%203b5d2d5fd7624af4a045a0b69189c479/_2021-05-20__5.28.24.png)

# 코드 구현

```python
def floyd_warshall(n, edges):
    # 그래프 정보를 담을 인접행렬, 거리는 무한대로 초기화
    adj = [[float('inf')] * (n+1) for _ in range(n+1)] 
    
    # 인접행렬에 그래프 정보 저장 (정점 u -> v 거리 w)
    for u, v, w in edges:
        adj[u][v] = w
    
    # k : 경유지 (각 정점들을 경유지로 설정)
    for k in range(1, n+1):
        for i in range(1, n+1):
            for j in range(1, n+1):
            	# 정점 i -> j로 갈 때 기존 거리값과 k를 거쳐갈 때의 거리 값 중 작은 값을 저장
                adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])
    
    return adj
    
# 정점 개수 & 간선 정보
n = 4  
edges =  [[1, 2, 4],
    [1, 3, 1],
    [2, 3, 2],
    [2, 4, 1],
    [3, 2, 1],
    [4, 1, 5],
    [4, 3, 5]]
    
# 결과 출력
dist = floyd_warshall(n, edges)
for i in range(1, n+1):
    print(dist[i][1:])
```

```python
from sys import stdin
from math import inf

n = int(stdin.readline())
m = int(stdin.readline())

# 이동 최소비용을 저장할 2차원 배열
cost = [[inf] * n for _ in range(n)]
for _ in range(m):
    a, b, c = map(int, stdin.readline().split())
    cost[a-1][b-1] = min(cost[a-1][b-1], c)

# 플로이드 와샬 알고리즘 적용
k in range(n):
    cost[k][k] = 0
    for i in range(n):
        for j in range(n):
            cost[i][j] = min(cost[i][j], cost[i][k]+cost[k][j])

# 결과 출력
for row in cost:
    for i in range(n):
        # 갈 수 없는 경로인 경우, 0 출력
        if row[i] == inf:
            row[i] = 0
        print(row[i], end=" ")
    print()
```

## 동빈나 코드

```python
INF = int(1e9) # 무한을 의미하는 값으로 10억을 설정

# 노드의 개수 및 간선의 개수를 입력받기
n = int(input())
m = int(input())
# 2차원 리스트(그래프 표현)를 만들고, 모든 값을 무한으로 초기화
graph = [[INF] * (n + 1) for _ in range(n + 1)]

# 자기 자신에서 자기 자신으로 가는 비용은 0으로 초기화
for a in range(1, n + 1):
    for b in range(1, n + 1):
        if a == b:
            graph[a][b] = 0

# 각 간선에 대한 정보를 입력 받아, 그 값으로 초기화
for _ in range(m):
    # A에서 B로 가는 비용은 C라고 설정
    a, b, c = map(int, input().split())
    graph[a][b] = c

# 점화식에 따라 플로이드 워셜 알고리즘을 수행
for k in range(1, n + 1):
    for a in range(1, n + 1):
        for b in range(1, n + 1):
            graph[a][b] = min(graph[a][b], graph[a][k] + graph[k][b])

# 수행된 결과를 출력
for a in range(1, n + 1):
    for b in range(1, n + 1):
        # 도달할 수 없는 경우, 무한(INFINITY)이라고 출력
        if graph[a][b] == 1e9:
            print("INFINITY", end=" ")
        # 도달할 수 있는 경우 거리를 출력
        else:
            print(graph[a][b], end=" ")
    print()
```
