# 벨만-포드 알고리즘

- 시작 정점으로부터 다른 모든 정점까지의 최단 경로를 찾기 위한 알고리즘
- 각 정점들을 돌아가면서 모든 간선들을 탐색한다.

    ( 맨 처음은 시작점부터 탐색하고 그 이후에는 순서가 상관 없다 )

- 방향 그래프에서 음의 가중치(ex - 시간)를 지닌 간선이 존재할 때 사용
- 음수 사이클 존재 여부를 판별할 수 있다는 장점

    ![%E1%84%87%E1%85%A6%E1%86%AF%E1%84%86%E1%85%A1%E1%86%AB-%E1%84%91%E1%85%A9%E1%84%83%E1%85%B3%20%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%80%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B3%E1%86%B7%204c7cf96641cd4d0f88e7410d461b33b8/_2021-05-20__4.19.54.png](%E1%84%87%E1%85%A6%E1%86%AF%E1%84%86%E1%85%A1%E1%86%AB-%E1%84%91%E1%85%A9%E1%84%83%E1%85%B3%20%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%80%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B3%E1%86%B7%204c7cf96641cd4d0f88e7410d461b33b8/_2021-05-20__4.19.54.png)

    - 만약 위와 같이 음의 가중치로 인해 순환 구조를 가지게 되면 최단경로를 구할 수 없다.
    - 이것을 확인하는 방법은 한번 더 모든 간선을 돌아보면 해결된다.
    - v-1번까지 돌았을 때 정상 그래프라면 모두 최단거리로 설정되있을텐데 한번 더 할때 값이 바뀌는 부분이 있다면 순환구조가 생긴 것이다.
- 다익스트라보다는 시간 복잡도가 크다 (O(ElogE) < O(VE))
    - 간선의 개수 E, 정점의 개수 V

# 사용 이유

1. 다익스트라처럼 최단 경로를 구하는 것이 목표
    - 시간복잡도는 벨만포드가 더 느리다
    - 변의 가중치가 음수라도 사용가능하기에 사용
2. 최단 경로를 구할 수 있는지 없는지 판별하는 과정
    - 음수 간선이 있는 경우
        - 음수 간선 순환이 없는 경우
        - 음수 간선 순환이 있는 경우 - 최단 경로 구할 수 없음

# 음수 사이클이 뭔데

- V-1번 반복이 끝난 이후, 한 번 더 위의 과정을 돌려주었을 때 값이 바뀐다면 음수 사이클이 있는 그래프임을 알 수 있다
- 음수 사이클이 존재하는 경우에는 음수 가중치를 계속해서 더해주게 되어 최단 거리를 구할 수 없는 무한 루프에 빠진다.

# 작동 원리

1. 시작 노드에 대해서 거리를 0으로 초기화, 나머지 노드는 거리를 무한으로 초기화
2. V-1번 다음 과정을 반복
    - 정점의 개수 V라 할때 최대 간선의 수는 V-1
3. 매 반복마다 모든 간선 확인
4. 현재 정점에서 모든 인접 정점들을 탐색하며, 기존에 저장되어 있는 인접 정점까지의 거리보다 현재 정점을 거쳐 인접 정점에 도달하는 거리가 더 짧을 경우 짧은 거리로 갱신해준다.
5. V-1번 반복 이후, V번째 반복에서도 거리 값이 갱신된다면 음수 순환이 존재

# 그림으로 설명

1. 시작점이 1일때, Dist[1]만 0으로 두고 나머지는 무한대로 설정

    ![%E1%84%87%E1%85%A6%E1%86%AF%E1%84%86%E1%85%A1%E1%86%AB-%E1%84%91%E1%85%A9%E1%84%83%E1%85%B3%20%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%80%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B3%E1%86%B7%204c7cf96641cd4d0f88e7410d461b33b8/_2021-05-20__3.59.26.png](%E1%84%87%E1%85%A6%E1%86%AF%E1%84%86%E1%85%A1%E1%86%AB-%E1%84%91%E1%85%A9%E1%84%83%E1%85%B3%20%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%80%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B3%E1%86%B7%204c7cf96641cd4d0f88e7410d461b33b8/_2021-05-20__3.59.26.png)

2. 시작점 1의 인접정점들을 탐색하며, Dist[노드]에 저장되어 있는 값보다 정점1을 거쳐 가는 값이 더 작을 경우 그  값으로 업데이트한다.

    ![%E1%84%87%E1%85%A6%E1%86%AF%E1%84%86%E1%85%A1%E1%86%AB-%E1%84%91%E1%85%A9%E1%84%83%E1%85%B3%20%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%80%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B3%E1%86%B7%204c7cf96641cd4d0f88e7410d461b33b8/_2021-05-20__4.04.55.png](%E1%84%87%E1%85%A6%E1%86%AF%E1%84%86%E1%85%A1%E1%86%AB-%E1%84%91%E1%85%A9%E1%84%83%E1%85%B3%20%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%80%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B3%E1%86%B7%204c7cf96641cd4d0f88e7410d461b33b8/_2021-05-20__4.04.55.png)

3. 가장 값이 작은 정점2가 다음 시작 기준점이 된다. 정점2의 인접 정점들을 탐색한다. Dist[4]의 가중치가 2를 거쳐가지 않을 경우에는 2인데 2를 거쳐가는 경우에는 -5가 되므로 갱신

    ![%E1%84%87%E1%85%A6%E1%86%AF%E1%84%86%E1%85%A1%E1%86%AB-%E1%84%91%E1%85%A9%E1%84%83%E1%85%B3%20%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%80%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B3%E1%86%B7%204c7cf96641cd4d0f88e7410d461b33b8/_2021-05-20__4.05.23.png](%E1%84%87%E1%85%A6%E1%86%AF%E1%84%86%E1%85%A1%E1%86%AB-%E1%84%91%E1%85%A9%E1%84%83%E1%85%B3%20%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%80%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B3%E1%86%B7%204c7cf96641cd4d0f88e7410d461b33b8/_2021-05-20__4.05.23.png)

4. 아래는 위의 상황을 반복

    ![%E1%84%87%E1%85%A6%E1%86%AF%E1%84%86%E1%85%A1%E1%86%AB-%E1%84%91%E1%85%A9%E1%84%83%E1%85%B3%20%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%80%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B3%E1%86%B7%204c7cf96641cd4d0f88e7410d461b33b8/_2021-05-20__4.05.51.png](%E1%84%87%E1%85%A6%E1%86%AF%E1%84%86%E1%85%A1%E1%86%AB-%E1%84%91%E1%85%A9%E1%84%83%E1%85%B3%20%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%80%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B3%E1%86%B7%204c7cf96641cd4d0f88e7410d461b33b8/_2021-05-20__4.05.51.png)

    ![%E1%84%87%E1%85%A6%E1%86%AF%E1%84%86%E1%85%A1%E1%86%AB-%E1%84%91%E1%85%A9%E1%84%83%E1%85%B3%20%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%80%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B3%E1%86%B7%204c7cf96641cd4d0f88e7410d461b33b8/_2021-05-20__4.06.00.png](%E1%84%87%E1%85%A6%E1%86%AF%E1%84%86%E1%85%A1%E1%86%AB-%E1%84%91%E1%85%A9%E1%84%83%E1%85%B3%20%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%80%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B3%E1%86%B7%204c7cf96641cd4d0f88e7410d461b33b8/_2021-05-20__4.06.00.png)

    ![%E1%84%87%E1%85%A6%E1%86%AF%E1%84%86%E1%85%A1%E1%86%AB-%E1%84%91%E1%85%A9%E1%84%83%E1%85%B3%20%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%80%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B3%E1%86%B7%204c7cf96641cd4d0f88e7410d461b33b8/_2021-05-20__4.06.07.png](%E1%84%87%E1%85%A6%E1%86%AF%E1%84%86%E1%85%A1%E1%86%AB-%E1%84%91%E1%85%A9%E1%84%83%E1%85%B3%20%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%80%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B3%E1%86%B7%204c7cf96641cd4d0f88e7410d461b33b8/_2021-05-20__4.06.07.png)

5. 최종적으로 {0,-4,5,-5,1}이 나오게 된다.

# 다익스트라와의 차이점

- 벨만 포드
    - 매 반복마다 모든 간선을 확인한다
    - 다익스트라에 비해 시간이 오래 걸리지만 음수 간선 순환을 탐지 가능
- 다익스트라
    - 매번 방문하지 않는 노드 중에서 최단 거리가 가장 가까운 노드만을 방문
    - 음수 간선이 없다면 최적의 해를 찾을 수 있다.

# 시간 복잡도

V-1번 인접한 모든 간선들을 검사하는 과정 거치기 때문에 "O(VE)"가 된다.

# 왜 V-1번씩 확인하는데

**최단 경로**라는 말은 **같은 정점을 두 번 지날 일이 없기 때문에** 가능한 최단 경로에서 거치는 간선의 개수는 많아봐야 **V-1**개입니다. 따라서 **루프를 V-1번 돌리는데, K번째 루프에서 시작점으로부터 각 정점으로 K개의 간선을 거쳐서 도달할 수 있는 최단 경로를 다 갱신해주는 것이 기본 아이디어**입니다.

# 코드 구현

```python
import sys
import collections
input = sys.stdin.readline
INF = int(1e9)

n, m = map(int, input().split()) # 노드 수, 간선 수 입력 받기
edges = [] # 모든 간선에 대한 정보를 담는 리스트 생성
dist = [INF] * (n+1) # 최단 거리 테이블을 모두 무한으로 초기화

# 그래프 생성
for _ in range(m):
    u, v, w = map(int, input().split()) # 노드, 인접 노드, 가중치
    edges.append((u, v, w))

# 벨만 포드 알고리즘
def bf(start):
    dist[start] = 0 # 시작 노드에 대해서 거리를 0으로 초기화
    for i in range(n): # 정점 수만큼 반복
        for j in range(m): # 매 반복 마다 모든 간선 확인
            node = edges[j][0] # 현재 노드 받아오기
            next_node = edges[j][1] # 다음 노드 받아오기
            cost = edges[j][2] # 가중치 받아오기
            # 현재 간선을 거려서 다른 노드로 이동하는 거리가 더 짧은 경우
            if dist[node] != INF and dist[next_node] > dist[node] + cost:
                dist[next_node] = dist[node] + cost
                # n번째 라운드에서도 값이 갱신된다면 음수 순환이 존재
                if i == n-1: # n-1번 이후 반복에도 값이 갱신되면 음수 순환 존재
                    return True
    return False

# 벨만 포드 알고리즘 수행
negative_cycle = bf(1)

if negative_cycle:
    print('-1')
else:
    # 1번 노드를 제외한 다른 모든 노드로 가기 위한 최단 거리 출력
    for i in range(2, n+1):
        if dist[i] == INF: # 도달할 수 없는 경우 -1 출력
            print('-1')
        else: # 도달할 수 있는 겨우 거리를 출력
            print(dist[i])
```

```python
def BellmanFord(G,w,s):
//초기화 과정
for each u in G.V:     //노드를 초기화 하기
      distance[v] = inf      //모든 노드의 최단거리를 무한으로 지정
      parent[v] = null       //모든 노드의 부모 노드를 널값으로 지정
distance[s] = 0 //출발점의 최단거리는 0으로 지정한다
//거리측정 과정
for i from 1 to len(G.V):   //노드의 숫자만큼
     for each (u,v) in G.E:   //모든 변을 체크해 최단 거리를 찾아본다.
          if distance[u] + w[(u,v)] < distance[v]:   
          //만약 u를 경유하여 v로 가는 거리가 현재 v의 최단 거리보다 짧으면
               distance[v] = distance[u] + w[(u,v)]  //그 거리를 v의 최단거리로 지정
               parent[v] = u   //u를 v의 부모 노드로 지정
//음수 사이클 체크 과정
for each (u,v) in G.E:
     if distance[u] + w[(u,v)] < distance[v]:
          return false //음수 사이클을 확인하고 알고리즘을 정지
return distance[], parent[]
```